# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'NextGenLogGuide.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
from setup_logger import logger
from PyQt5 import QtCore, QtGui
from PyQt5.QtWidgets import QMainWindow,QFileDialog,QAction,QTreeWidgetItem,QProgressBar,QMessageBox,QLabel
from PyQt5.QtGui import QIcon
from utils import *
from PyQt5.QtCore import QThreadPool,Qt,QTimer
from GccGraph import Ui_GccGraph
from about import Ui_About

__filename__ = "NextGenLogGuideGui.py"

class Ui_MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi()    
        self.add_signals()
     
    def setupUi(self):
        self.setObjectName("MainWindow")
        width,height = get_screen_resolution()
        self.resize(width-5, int(height - (height*(15/100))))# 90 % of screen height
        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(12)
        font.setBold(False)
        font.setUnderline(True)
        font.setWeight(50)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.treeWidget = QtWidgets.QTreeWidget(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.treeWidget.sizePolicy().hasHeightForWidth())
        self.treeWidget.setSizePolicy(sizePolicy)
        self.treeWidget.setObjectName("treeWidget")
        #self.treeWidget.headerItem().setText(0, "1")
        self.verticalLayout.addWidget(self.treeWidget)
        self.gridLayout_2.addLayout(self.verticalLayout, 0, 0, 1, 1)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(12)
        font.setBold(False)
        font.setUnderline(True)
        font.setWeight(50)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setObjectName("textBrowser")
        self.verticalLayout_2.addWidget(self.textBrowser)
        self.gridLayout_2.addLayout(self.verticalLayout_2, 0, 1, 1, 1)
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)
        self.pushButton.setFont(font)
        self.pushButton.setObjectName("pushButton")
        self.gridLayout.addWidget(self.pushButton, 0, 0, 1, 1)
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setFamily("Arial")
        font.setPointSize(9)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")
        self.gridLayout.addWidget(self.pushButton_2, 0, 1, 1, 1)
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setObjectName("lineEdit")
        self.gridLayout.addWidget(self.lineEdit, 0, 2, 1, 1)
        self.gridLayout_2.addLayout(self.gridLayout, 1, 0, 1, 2)
        self.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar()
        self.menubar.setGeometry(QtCore.QRect(0, 0, 807, 21))
        self.menubar.setObjectName("menubar")
        self.menuOpenfile = QtWidgets.QMenu(self.menubar)
        self.menuOpenfile.setObjectName("menuOpenfile")
        self.menuHelp = QtWidgets.QMenu(self.menubar)
        self.menuHelp.setObjectName("menuHelp")
        self.menuOptions = QtWidgets.QMenu()
        self.menuOptions.setObjectName("menuOptions")
        self.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar()
        self.statusbar.setObjectName("statusbar")
        self.setStatusBar(self.statusbar)
        self.actionOpenFile = QtWidgets.QAction()
        self.actionOpenFile.setObjectName("actionOpenFile")
        self.actionOpenFolder = QtWidgets.QAction()
        self.actionOpenFolder.setObjectName("actionOpenFolder")
        self.actionAbout = QtWidgets.QAction()
        self.actionAbout.setObjectName("actionAbout")
        self.actionFull_GCC_Graph = QtWidgets.QAction()
        self.actionFull_GCC_Graph.setObjectName("actionFull_GCC_Graph")
        self.actionParse_Log = QtWidgets.QAction()
        self.actionParse_Log.setObjectName("actionParse_Log")
        self.actionParse_stresslogs = QtWidgets.QAction()
        self.actionParse_stresslogs.setObjectName("actionParse_stresslogs")
        self.actionParse_soaklogs = QtWidgets.QAction()
        self.actionParse_soaklogs.setObjectName("actionParse_soaklogs")

        self.actionSaveReport = QtWidgets.QAction()
        self.actionSaveReport.setObjectName("actionSaveReport")
        self.actionQuit = QtWidgets.QAction()
        self.actionQuit.setObjectName("actionQuit")
        self.menuOpenfile.addAction(self.actionOpenFile)
        self.menuOpenfile.addAction(self.actionOpenFolder)
        self.menuOpenfile.addAction(self.actionSaveReport)
        self.menuOpenfile.addSeparator()
        self.actionRecentFiles = self.menuOpenfile.addMenu("Recent Files") 
        self.actionRecentFiles.triggered.connect(self.recentFileAction)
        self.menuOpenfile.addAction(self.actionQuit)
        self.menuHelp.addAction(self.actionAbout)
        self.menuOptions.addAction(self.actionFull_GCC_Graph)
        self.menuOptions.addAction(self.actionParse_Log)
        self.menuOptions.addAction(self.actionParse_stresslogs)
        self.menuOptions.addAction(self.actionParse_soaklogs)
        self.menuOptions.addAction(self.actionParse_Log)
        self.menubar.addAction(self.menuOpenfile.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())
        logger.debug(__filename__,"setup called")

        initglobals()        
        self.setWindowTitle((str ( 'NexGenLogGuide ' +'-' + get_version())))
        self.label.setText("List of files")
        self.label_2.setText("Initial log information")
        self.pushButton.setText("Open File")
        self.pushButton_2.setText("Open Folder")
        self.menuOpenfile.setTitle("File")
        self.menuHelp.setTitle("Help")
        self.menuOptions.setTitle("Options")
        self.actionOpenFile.setText("OpenFile")
        self.actionOpenFolder.setText("OpenFolder")
        self.actionAbout.setText("About")
        self.actionFull_GCC_Graph.setText("Full GCC Graph")
        self.actionParse_stresslogs.setText("Parse stress log")
        self.actionParse_soaklogs.setText("Parse soak log")
        self.actionParse_Log.setText("Parse Log")
        self.actionSaveReport.setText("SaveReport")
        self.actionQuit.setText("Quit")

        # Till above it was generated by pyuic5.exe

        self.statusBar().showMessage('Ready')
        self.lineEdit.setReadOnly(True)
        self.actionOpenFile.setToolTip('Open NexGen Log File for parsing')
        self.actionOpenFolder.setToolTip('Open folder contains Log File(s) for parsing')
        self.pushButton.setToolTip('Open NexGen Log File for parsing')
        self.menuOpenfile.setToolTipsVisible(True)
        self.pushButton_2.setToolTip('Open folder contains Log File(s) for parsing')

        self.treeWidget.setColumnCount(2)
        self.treeWidget.setHeaderLabels(["S.No","File Name", "Size"])
        #twidth = self.treeWidget.sizeHint().width() - int((self.treeWidget.sizeHint().width() / 3))
        twidth = self.treeWidget.sizeHint().width()

        self.treeWidget.header().resizeSection(0,int(twidth*.10))
        self.treeWidget.header().resizeSection(1,int(twidth*.60))
        self.treeWidget.header().resizeSection(2,int(twidth*.30))
        self.treeWidget.header().setStretchLastSection(False)
        self.treeWidget.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        bfont = self.textBrowser.font()
        bfont.setFamily('Courier New')
        bfont.setPointSizeF(10)
        self.textBrowser.setFont(bfont)

        self.status = self.statusBar()
        self.progress = QProgressBar()
        self.status.addPermanentWidget(self.progress)

        self.read_config_file('LogConfig.json')
        if (self.status == True):
             self.OnlineRegCount , self.OnlineRegex =  get_regex_from_list(self.onliner)
        else:
            logger.error(__file__,'Failed to read regex')
            self.statusBar().showMessage('Error reading LogConfig.json. Please check')

        self.threadpool = QThreadPool()
        logger.info("Available with maximum %d threads" % self.threadpool.maxThreadCount())


        #Initialze the class varibles
        self.terminate_active_thread = False
        self.worker = None
        self.lbl = None
        self.recentFileList = []
        self.recentFileListCount = 0

        #Read recent file list 
        self.loadRecentFilestoMenu()

    def OpenFileDialog(self):
        try :
            file_name, filter = QFileDialog.getOpenFileName(self, 'Open NextGen Log files',
                                'c:\\', "NextGen Log files (*.log)")
            
            logger.debug(__filename__,'file name :',file_name)
            self.ProcessFile(file_name)
        except FileNotFoundError:
            logger.debug(__filename__,'No file selected')

    def OpenFolderDialog(self):
        try :
            folder_name = QFileDialog.getExistingDirectory(self, "Select NextGenLog Directory")
            logger.debug(__filename__,folder_name)
            if folder_name =='':
                return
            self.ProcessFolder(folder_name)
        except FileNotFoundError:
            logger.debug(__filename__,'No folder selected')

    def add_signals(self):
        self.pushButton.clicked.connect(self.OpenFileDialog)
        #self.pushButton.clicked.connect(self.create_thread([],[]))
        self.pushButton_2.clicked.connect(self.OpenFolderDialog)
        self.actionOpenFile.triggered.connect(self.OpenFileDialog)
        self.actionOpenFolder.triggered.connect(self.OpenFolderDialog)
        self.actionQuit.triggered.connect(self.closeEvent)
        self.actionSaveReport.triggered.connect(self.file_save)
        self.actionFull_GCC_Graph.triggered.connect(self.open_GccGraph)
        self.actionAbout.triggered.connect(self.open_about)
        # Connect the contextmenu
        self.treeWidget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeWidget.customContextMenuRequested.connect(self.menuContextTree)
        self.treeWidget.itemSelectionChanged.connect(self.showfilename)

    def process_log_files(self, file_list, fn_send_data):
        print("Thread started")
        logger.info(__filename__,"Thread started")
        count = 0
        for file in file_list:
            if True == self.terminate_active_thread:
                print("Terminate the thread")
                logger.info(__filename__,"Terminate the thread")
                break
            count = count + 1
            fn_send_data.emit(('file',file,count))
            logger.info(file)
            filecontent = extract_onliner_info(self.OnlineRegCount,self.OnlineRegex,file)
            fn_send_data.emit(('data',file))
            fn_send_data.emit(('data','='*len(file)))
            if(filecontent is not None):
                for item in filecontent: 
                    fn_send_data.emit(('data',item))
            else:
                fn_send_data.emit(('data',"<font color=red size=9>No data available to present for this file</font>"))
            
            fn_send_data.emit(('data',"************END OF FILE**********\n"))
        return 'done'

    def read_config_file(self,filename):
        self.status, self.onliner, self.settings, self.lFullGcc = ReadConfigfromJson(filename)
        logger.info(self.status, self.onliner, self.settings, self.lFullGcc)

    def thread_complete(self):
        print("THREAD COMPLETE!")
        
        if self.worker is not None:
            self.worker.isalive = False
            self.worker.signals = None
            self.worker = None
        self.statusBar().showMessage('Files processing Completed')

    def show_data(self,d_tuple):
        if(d_tuple[0]=='file'):
            self.statusBar().showMessage('processing file:{}'.format(d_tuple[1]))
            self.progress.setValue(d_tuple[2])
        elif(d_tuple[0]=='data'):
            self.textBrowser.append(d_tuple[1])
        else:
            logger.error("Invalid- Not expected")

    def show_error(self,d_tuple):
        logger.error(__filename__,d_tuple)
        QMessageBox.critical(self, 'Error',
                            "Exception caught:\n{}".format(d_tuple[2], QMessageBox.Ok))
        
        
    def create_thread(self,file_list, log_info_list):
        # Pass the function to execute
        self.worker = JobThread(self.process_log_files,file_list)
        self.worker.signals.finished.connect(self.thread_complete)
        self.worker.signals.send_data.connect(self.show_data)
        self.worker.signals.error.connect(self.show_error)
        
        # Execute
        logger.info("Thread created for processing files")
        self.threadpool.start(self.worker)

    def closeEvent(self, event):

        if self.lbl is not None: #Splash screen is there
            if not type(event) == bool:
                event.accept()
            else:
                sys.exit()
        else:
            message = "Are you sure to quit?"
            if self.worker is not None and True == self.worker.isalive:
                message = "Thread is busy. "+ message
                
            reply = QMessageBox.question(self, 'Message',
                                        message, QMessageBox.Yes |
                                        QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                writeRecentFilestoFile(self.recentFileList)
                if self.worker is not None and True == self.worker.isalive:
                    self.terminate_active_thread = True
                    if not type(event) == bool:
                        event.ignore()
                        QTimer.singleShot(0,self.splashscreen)
                    if not type(event) == bool:
                        event.ignore()
                else:       
                    if not type(event) == bool:
                        event.accept()
                    else:
                        sys.exit()
            else:
                if not type(event) == bool:
                    event.ignore()

    def file_save(self):
        fname,fil = QFileDialog.getSaveFileName(self, 'Save File',filter='*.txt')
        if fname != '':
            file = open(fname,'w')
            text = self.textBrowser.toPlainText()
            file.write(text)
            file.close()
            self.statusBar().showMessage("File saved sucessfully: {}".format(fname))
        else:
            logger.error(__filename__,"Save file is not successful")

    def GccGraph_thread(self,filename,gccobj):
        # Pass the function to execute
        self.worker = JobThread(gccobj.get_Gcc_values,filename)
        self.worker.signals.finished.connect(self.thread_complete)
        self.worker.signals.send_data.connect(gccobj.show_data)
        self.worker.signals.error.connect(gccobj.show_error)

        # Execute
        logger.info("Thread created for processing files")
        self.threadpool.start(self.worker)

    def open_GccGraph(self):
        if self.worker is not None:
            QMessageBox.critical(self, 'Warning',
                                     "Thread is busy. Please wait (.*.)", QMessageBox.Ok)
            return 
                    
        graph_widget = QtWidgets.QDialog()
        print(self.lineEdit.text() ,self.selected_fname)
        fname =os.path.join(self.lineEdit.text(), self.selected_fname)
        gcc_obj = Ui_GccGraph(fname,self.lFullGcc)
        gcc_obj.setupUi(graph_widget)
        self.GccGraph_thread(fname,gcc_obj)
        graph_widget.exec_()
        

    def open_about(self):
        graph_widget = QtWidgets.QDialog()
        about_obj = Ui_About()
        about_obj.setupUi(graph_widget)
        graph_widget.exec_()

    def menuContextTree(self, point):
            # Infos about the node selected.
            index = self.treeWidget.indexAt(point)
            if not index.isValid():
                return

            item = self.treeWidget.itemAt(point)
            self.selected_fname = item.data(0,Qt.UserRole)  
            self.menuOptions.exec_(self.treeWidget.mapToGlobal(point))

    def showfilename(self):
        for item in self.treeWidget.selectedItems():
            self.statusBar().showMessage( '{}'.format(item.data(0,Qt.UserRole)))
    
    def splashscreen(self):
        self.lbl = QLabel('<font color=Red size=16><b> Terminating thread... Please wait for 5 Secs </b></font>')
        self.lbl.setWindowFlags(Qt.SplashScreen | Qt.FramelessWindowHint|Qt.AlignCenter)
        self.lbl.show()
        QTimer.singleShot(5000,self.close)

    def add_recentFile(self,filename):
        maxcount = get_recent_file_size()
        if len(self.recentFileList) < maxcount: #self.recentFileList - Zero based
            submenuobj = self.actionRecentFiles.addAction(filename)
            self.recentFileList.append(submenuobj)
            self.recentFileListCount = self.recentFileListCount + 1
        elif self.recentFileListCount > (maxcount-1):
            menuaction = self.recentFileList[self.recentFileListCount % maxcount]
            menuaction.setText(filename)
            self.recentFileListCount = self.recentFileListCount + 1

    def recentFileAction(self,data):
        print(data.text())
        path = data.text()
        if os.path.isdir(path):  
            self.ProcessFolder(path,True)      
        elif os.path.isfile(path):
            self.ProcessFile(path,True)

    def ProcessFile(self,file_name, isfrom_menu = False):
        path, filename = os.path.split(file_name)
        self.lineEdit.setText(os.path.dirname(file_name))
        fsize = os.path.getsize(file_name)
        fsizestr = str(int(fsize/1024)) + ' KB'
        self.treeWidget.clear()
        item = QTreeWidgetItem(self.treeWidget, ['1',filename, fsizestr])
        self.statusBar().showMessage('processing file. Please wait...')
        self.progress.setMaximum(1)
        self.textBrowser.clear()
        item.setData(0,Qt.UserRole,filename)
        if  False == isfrom_menu:
            self.add_recentFile(file_name)
        self.create_thread([file_name],[])

    def ProcessFolder(self,folder_name,isfrom_menu = False):

        self.lineEdit.setText(str(folder_name))
        files_list = get_files_from_dir(folder_name,".log")
        if(len(files_list) == 0):
            QMessageBox.critical(self, 'Error',
                        "No files found with extension '.log'", QMessageBox.Ok)

            self.statusBar().showMessage('Please select valid folder.')
            return

        if  False == isfrom_menu:
            self.add_recentFile(folder_name)

        self.textBrowser.clear()
        self.statusBar().showMessage('Fetching file from folder. Please wait...')
        self.treeWidget.clear()
        count = 0
        for file in files_list:
            fsize = os.path.getsize(file)
            fsizestr = str(int(fsize/1024)) + ' KB'
            path, filename = os.path.split(file)
            count = count + 1
            item = QTreeWidgetItem(self.treeWidget, [str(count),filename, fsizestr])
            item.setData(0,Qt.UserRole,file)
        self.statusBar().showMessage(f"Fetching file from folder completed. Total file(s): {len(files_list)}")
        self.progress.setMaximum(count)
        self.create_thread(files_list,[])

    def loadRecentFilestoMenu(self):
        filelist = LoadRecentFilestoFile()
        logger.debug(__filename__,len(filelist),filelist)
        for fname in filelist:
            self.add_recentFile(fname)
            